---
layout: post
title: 杂谈
key: 201910211243
tags: 杂谈
---






2019-12-10
---
C/C++不应该有垃圾回收。只要C/C++还是操作系统的主要实现语言，C/C++就不会有内置垃圾回收机制。这是近日看了[《垃圾回收的算法与实现》](https://book.douban.com/subject/26821357/)前几章后有感。书中没谈该到观点。只是明白了书中要表达到的意思后，回想起常有人抱怨C/C++没有垃圾回收，固有此想。

看了前面几章，主要介绍了几个GC算法：位图标记，复制gc，引用计数和分代gc。尽管这么多算法，但每种算法都解决同一个问题，对象什么时候被释放才是效率最大。因为频繁使用的对象就算没被引用，在空间和性能允许的条件下也应该被继续保留，而不是立即清除。保留多久的问题上就是各个GC实现细节差异。引用计数认为当计数小于等于0时就要释放对象，而分代认为最后创建的对象会被优先考虑GC。而算法在性能和空间的微小取舍上派生子版本。如标记GC算法，扩展出了复制标记和压缩标记算法。

各个垃圾回收算法各有特点，不存在一个通吃所有情况的GC算法。 C/C++的一大特性是“靠近”操作系统，为了更好性能，操作系统的核心部分是用C/C++和汇编语言写的，这里不是业务层，无法知首具体要处理的问题，如果是C/C++语言的设计者，使用哪个作为内置GC算法？答案是不解决这个问题。由业务层框架解决垃圾回收算法问题，根据使用场景特性选择适当的回收方案。

恐怕C/C++的完美之一是没有垃圾回收！


2019-12-8
---
个人认为单例模式是经常被玩坏了的设计模式。常看到业务框架中出现一大坨单例，究竟是需要单例还是用全局对象呢？频繁地敲打字符“GetInstance()”令我感到厌倦。回顾一下单例模式的需求特性：1. 类型不能实例化多次，否则内部会产生逻辑冲突。2.业务范围内不能获取到实例。然而我所遇到过大多数的单例都不满足条件1，可以很轻松实例化多次。而条件2是大家都喜欢使用它的原因，全局访问特性，能快速将功能“拼凑起来”。但它代价是放弃了进一步思考框架的解耦和内聚性。大多数情况下，我个人偏向用全局对象来替代单例，如果app是程序入口的全局对象，app.audio则是声音控制的管理对象。




2019-10-21
---
开源代码的功能要简洁。或者说刚好满足需求就好。功能越丰富，框架设计会考虑更多、更复杂、代码量更大。当增删改代码时，最终额外增加与需求不相关的人力成本。

---



<br>	
<br>	
<b>原文:<br>
<https://lizijie.github.io/2019/10/21/%E6%9D%82%E8%B0%88.html>
<br>
作者github:<br>	
<https://github.com/lizijie>	
</b>
