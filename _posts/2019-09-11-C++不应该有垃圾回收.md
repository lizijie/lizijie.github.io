---
layout: post
title: C++不应该有垃圾回收
key: 201909111143
tags: C++ 杂谈
---

[TOC]

只要C/C++还是操作系统的主要实现语言，C/C++就不会有内置垃圾回收机制。

![](https://raw.githubusercontent.com/lizijie/lizijie.github.io/master/assets/images/2019-09-11-C%2B%2B%E4%B8%8D%E5%BA%94%E8%AF%A5%E6%9C%89%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/gc.jpg)

近日看了这本书前几章，然而书中完全没谈该观点。理解了书中主旨后，回想起常有人抱怨C/C++没有垃圾。顿足思片刻，立此结论。

我大概看前面几章，介绍了如下几个GC算法：位图标记，复制gc，引用计数和分代gc（后面章节还有很多）。尽管这么多算法，但每种算法都解决同一个问题，对象什么时候被释放才是效率最大。因为频繁使用的对象就算没被引用，在空间和性能允许的条件下也应该被继续保留，而不是立即清除。保留多久的问题上就是各个GC实现细节差异。引用计数认为当计数小于等于0时就要释放对象，而分代认为最后创建的对象会被优先考虑GC。而算法在性能和空间的微小取舍上也出现了各个版本。如标记GC算法，扩展出了复制标记和压缩标记算法。

各个垃圾回收算法各有特点，有它们最优的使用场景。 那么换个角度，如果你是C/C++语言的设计者会选哪个作为内置垃圾回收算法？C/C++的一大特性是“靠近”操作系统，为了更好性能操作系统的核心部分是用C/C++和汇编写的。我认为在底层用哪一个都不适当，即此层面不解决这问题。低层及开放申请和释放内存，由上层框架解决垃圾回收，或者各项目根据使用场景特性选择或自实现适当回收方案。

恐怕C/C++的完美之一是没有垃圾回收！

<br>	
<br>	
<b>原文:<br>
<https://lizijie.github.io/2019/09/11/C++%E4%B8%8D%E5%BA%94%E8%AF%A5%E6%9C%89%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.html>
<br>
作者github:<br>	
<https://github.com/lizijie>	
</b>
