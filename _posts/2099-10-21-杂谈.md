---
layout: post
title: 杂谈
key: 209910211243
tags: 杂谈
---

- 2025-12-01

---

**关于订阅AI代码编辑器  PS: 从【面向object编程】到【面向AI编程】**

我年初连续开了好几个月的windsurf，15美元/月，有500次/请求，正常使用一个月下来200次，有时月底强迫想些事件去做消耗次数，大抵也就300出头多点，当时用完它感觉非常困难。

把钱给白白浪费，这非常不好。于是在6月份左右我关闭了windsurf订阅

- 之后我充了一个月cursor，它的计费已经堕落了（号称提供的模型全网低价，累计从订阅的20美元里扣，用不完不退且清零），正常使用习惯，用下来第3个星期就用完了。。。

- 再之后，大半年没用vscode后，我更新到最新版本重新用来起。
    - 没tap jump功能，写代码非常不顺畅，我承认windsurf和cursor的tab jump成功培养了用户。
    - 更甚是，vscode github copliot经常无故断开，晕。。。

- 我没有卸载windsurf，它已成为主力编辑器。因为它的两个高频使用功能是免费不限量（cursor和vscode非订阅限量）
    - 代码自动补全
    - tab jump

**从openroute使用免费/付费模型**

用AI模型久，我发现它以下特点

- 越问越糊涂。个人猜测：给的因子越多（即多次提问），如果你开头没有给到它准确的目标，那么AI将帮你产生目标，对于你来说AI认为的目标极可能偏离你想要的内容

- 开马行空。个人猜测：高级模型，特别是claude系列，我有时偷赖没有写完整，但是cluade想得非常多，非常多不是我想要的内容，结果就是“烧掉了不必要t的钱”。

- 短暂失忆。个人猜测：特别是winsurf/cursor有index cache的，好像当还未同步完成时。尽管我@代码文件，它好像没读到新内容，此时回复不准确

所以，大多数时候，我期望

- 一个干净的上下状态

- 免费的高新模型

**我习惯拆解细问题后**

- 用web chat端。用得最多的Web端包括：qwen/google ai studio/chatgpt
- cline/kilo code。尽可能@最低粒度范围内容操作
- openrounter里有免费模型，新上模型会有短期免费。复杂的代码的问题会用到付费旗舰模型

web端占据我80%的AI使用量，剩下的20%用在自动编码。一个月下来在openrouter的付费5美元左右

2025-03-11
---
不以编程领域去看待cursor/windsurf/trae这类工具，能做些什么？

随便写写的，不要认真，以下纯猜想，

当产品
- 数据不公开或未融合ai功能
- 同一产品下多个数据对象ai联动
- 不同产品下的ai联动。
需要公司合并/联合整个产品，或者有大佬重做，整出一个巨无霸产品

如果想自己diy，作为工作的生产力
​那么就是针对私人数据整活了。如包括但不限于笔记、excel/world、自用数据库等

只要产品能导出纯文本就行(即数据)。然后用ai编程工具打开导出的内容，编写本地prompts（即算法）,数据和算法都有了能干好多事情了。全过程无需懂编程，会打字就行。
​
​对于笔记我开始渐渐导出，用windsurf打开，ai加持起飞。叫ai帮我生成索引目录，润色，整理零散的内容，一条prompt将原来印象笔记的式转为md格式。
具体事例：以前花半天整理零散笔记，现在1分钟就完成（5秒出结果秒55秒人工检查）效果比我自己整理还好
​
​Excel表定义好表头，和其它表的关联，导出csv文本格式，做数据校验/分析/优化。待验证不导出csv行不行
​
​以上，prompt，有多大影响（算法）对使用者是模糊的，可认为算法不可控。那可先设计好（数据），输出效果会更好。


2025-01-19
---
我在想未来未来未来

有没有可能

人类后脑插管接入ai

“ai增强型人类”

人类变得更强

- 对话体验
自12月底 DeepSeek 发布后，我开始轮流使用 Cursor、Claude、DeepSeek 和 ChatGPT，以对话体验进行比较。从个人感觉来看，ChatGPT 在解答问题方面表现最佳。相同问题重复出现时，Claude 和 DeepSeek 需要不断追问，有时感觉像是在“打哈哈”，始终无法给出确切答案，而 ChatGPT 则通常无需太多追问即可直接给出正确答案。当然，这仅是个人体验。
- 代码自动补全
在代码补全方面，我对比了 DeepSeek API + Continue 和 Cursor：
    Cursor 试用了 Pro 版两周，但一周内我就用完了词条配额，感觉消耗较快。
    DeepSeek API + Continue 的补全效果远不及 Cursor，且大多数情况下生成的内容并非我想要的。此外，DeepSeek 在补全时存在明显的卡顿问题。
- 代码分析
这一部分未进行工具对比，我一直使用 DeepSeek，整体体验还可以，主要用于以下场景：
    代码优化与精简
    生成代码注释
    分析调用过程不清晰的代码
从个人使用情况来看，Cursor 在代码相关任务上更具优势，生成内容质量明显更高。
- 总结与选择
在代码编写方面，Cursor 绝对领先，代码补全几乎可以直接通过 Tab 快速完成，使用体验极佳，甚至让我有种化身“编程策划师”，指挥 AI 进行开发的感觉。
然而，我认为代码补全虽然方便，但并非刚需，解决问题才是核心需求。DeepSeek API + Continue 仍然勉强可用，因此暂未考虑升级 Cursor 付费版。我认为 Cursor 更像是深度适配 AI 编程的工具，而不是单纯依赖 AI 模型本身的胜出。我期待未来出现一个更适合 AI 的 VS Code 大杀器级插件。

- 考虑到 Cursor 和 ChatGPT 价格相近，而 ChatGPT 可玩性更高，我最终选择了 ChatGPT 会员。

2024-09-09
---
从chatgpt一出来时，我就有去尝试了。当时我的印象是，做不了复杂大而全的问题，回答内容浅薄，回答不准确，提高工作效率不大甚至无效。不知有多少人，也同样因此没再继续用chatgpt了。最近3个月，我又重新用起了chatgpt，我是免费版本的，经常会用完词条数量，要等几个小时重置词条数量。
- 工作效率。不要急着直接将大问题掉给它，先拆解你的大问题，提交拆解后小而精且局部的问题，我发觉这样，回答的准确率很高/很有用/很高效。
- 内容浅薄。chatpgt像是个什么都懂一点的老师，什么都懂一点这本身就已经很强。在运用一个不十分熟悉的技能，非常能回答我好奇的"十万个为什么"。加不懂和恐惧，那就先不要出现，对不理解的内容接着提问就可以了，循续逐精&学习&反馈这个过程chatgpt就很像一个老师。
- 回答不准确。以小而精/局部的方式提问，会提高回答准确率。我试过好几次打错几个字了，chatpgt也能准确知道我要问啥呢。有时也可能心里想的问题，和手打出来描述不是一会事，那当然结果就不对了

2023-04-04
---
[不懂为啥现在的游戏公司都把精力放在提高画面建模上面，而不是提高游戏性?](https://www.zhihu.com/question/585892816/answer/2968414715)答：就像网红餐厅,  先不管好不好吃，至少拍出来的照要好看，才能勾引你去呀。货物可能不是很好，但包装要够上档次，这样收礼人就不会认为是差东西。好看->细节到位->制作精良->好东西，虽然这个过程不是绝对成立。在你还未去了解该游戏更多的内容前，你对它的第一观感（即美术效果），再加前面的惯性联想，省去你去判断这是不是个好游戏，成功吸引你的注意。

2022-10-22
---
主程应是布道者
* 以初学者的角度思考问题，回归本源，返璞归真
* 不要过分指责复杂任务的错误。因为任谁去做都大概率出现问题
* 分散工作量，集中式决策

返工是对项目的极大损害
* 项目开过程应该避免任务返工。
* 量化可推进项目进度的内容。

2022-10-01
发觉很多人在讨论同步算法时，及及讨论坐标的同步上，而忽略核心玩法同步，或者说坐标同步仅是同步算法一部分
  
同步是为了展现效果的一致，而核心战斗玩法就是要表现的效果。优秀的同步算法就是解决核心战斗的业务问题。那么任何影响坐标和角度的行为都应被考虑进同步算法。比如技能会击飞目标，要如何表达击飞过程？按照同步位置和角度可以解决一切问题的思路，击飞过程同步坐标和角度就好要·
  
在编程领域里，研究算法时，必定同时讨论数据结构。对应到同步算法中，会是坐标、角度和各式各样的玩法数据。理论任何增加在核心玩法的内容，都可能会影响数据结构&算法。

2022-08-27
---
网络重连后是否需要数据包重发？有此疑问是因为，看到同事非常坚持认为非战斗系统要在网络不稳定时支持数据包重发，甚至拿出例证说腾讯某某游戏也是这么做。分析了我们的游戏项目的实际情况后，非战斗游戏系统不存在让数据包重发的条件，完成可以通过其它方法做到腾讯某某游戏重连的表现。比如1. 要求有数据包返回才加载界面 2. 重连成功后，重载当前场景，场景本身的业务逻辑会触发新一次数据请求。
数据包重发，实际就是不断地向服务端发包，潜在着对服务端的安全问题。另外，重发数据包无法解决一个非技术难题。一个合理的现象是，当玩家遇到反馈延时，极可能再次/多次点击。这个反馈延时其中就有可能网络不稳定，导致数据包回包慢导致。问题的严重性在于，如果这个点击是一个是消耗类操作！！！重发数据包，意味着再次请求消耗！！！而玩家的期望其实只想1次。。。所以这种情况下，是否重发数据，可能需要做过滤或交由业务自己解决。

2021-12-03
---
多年前呆过的一个项目，其版本开发总是延期，抛开中途需求变更、开发流程/管理不完善、老板强势介入或不可抗力等原因，仅从技术开发自身角度考虑未能如期交付的原因包括：1.过于自信报的工期很短 2.随意评估工期 3.开发中发有现技术难点 4.以为工期有空余，工作慢慢做 5.接手他人代码做的需求，改之前可能需要先熟悉需求/代码 6.没有看清楚文档，漏了要做的功能 6.没能察觉需求出有坑！需求描述不够充分/仅口头描述，但实际暗藏着额外工作量。
归结起来就是没有理清楚需求就写代码。行业一个解决办法写【设计文档】，但管理者认为它不是（也不可能是）应用程序里要展现的内容，做的话反而拉长了版本开发时间。执行者认为这是一个额外工作内容，变相压缩了开发工期，被迫加班赶进度。
我是主张将【设计文档】纳入开发流程，并给予额外的工期。【设计文档】不仅仅是画画流程图，它的意义为了驱动执行者理清/提问需求、思考代码流程/数据结构、结合自己的技术熟练程度评估工期。它是执行者与管理者之间的“开发契约”，管理者可以观察是否严重夸大工期，执行者可以拒绝超出“契约”外的需求。
* 需求工作量一次给太大，评估的工期也会很长。容易给执行者“时间很多”的错觉，导致前期慢慢做，后期赶成狗！
* 需求的各要点工期不宜太紧凑，否则工作节奏会很压迫，一旦中途出现意义就必然延期了。所以适当将评估工期比实际大那么一点来应对开发风险。但夸大了的工期会在“开发契约”被发现。

2021-12-02
---
选择哪个开发节奏？1.边写代码边调试，2.写完所有代码再调试。【方式1】的缺点是频繁切换调试端与代码编辑器，调试端每次都可能都要耗时去启动-加载，而大多数情况只是为了解决当前可见的一个问题，效率比太低。【方式2】是1次切换，尽可能多的发现问题。放在最后调试，难道就不怕，当代码写错要重新设计工期却不足了？这是有前提的，接到需求不要急于写代码，先做需求分析，尽可能穷尽所有问题，提出疑问，此时大概能思索出代码的框架，基本可以保证不会有大错，出现重新设计的概率极低。然而也有使用【方式1】的情况，就是工作量很大，预估要几周才能完成，开始只对问题作了关键点分析，没有展开细节，所以会先写完大部分关键点代码用简单数据模拟调试，之后每填充完一定量的细节代码就进行局部调试。另外按工作经验来看，需求越复杂预估工期与实际浮动越大，万一工期预估少了！边写边调的方式下，在早期完成关键点后，还能有机会重新审视工期。

2021-12-01
---
最近在想，编程技术成长过程，什么是重要的能力？1.把玩工具/插件？如折腾插件将编辑弄得那么“独一无二”，我觉得无所谓，弄得表面上看得那么的科技感，不见得个人很有技术含量。除非你的领域是写插件/工具/开发流程辅助。想了解领域的最新工具，毫不费力地去讨论/技术群看一眼就够了，基本都是“月经”内容。2.收集各种技术资源/文章/代码？对内容/方案最好要有自己的看法。3.热衷业务框架/设计模式？解决问题不应该先想着要套用哪个设计模式，这个思维（技术驱动需求）彻底的错。正确地是理清需求需求需求TMD还是需求！！只要解决好当前问题，并抽象了其中有相同规则的需求。最终不知不觉可能就是某个设计模式。
总结来说，个人认为：
1.资源检索。当考虑问题时，能快速地知道在哪里能找到提示。所以平时就应该要有技术积累。比如笔记、哪本书、哪个网站讨论/发贴、或者知道哪个网友/同事做过等
2.技术知识。技术的广度/深度，影响着解决方案的技术落地，技术越好落地方案就越好。这也是为什么在应用开发中，做操作系统与业务之间业务框架工作的技术人员，一定要具备扎实的技术知识，否则肯定做不好。
3.问题分析&解决。这是跟技术知识无关的思维方式。日常开发就是一个很好的提升思维能力的训练机会。不要先急于写代码，学会需求分析，理清需求/提出疑问/流程顺序/需求关系/冲突点/代码结构.
4.团队沟通/技术共识。工程开发不是单打独斗，个人冲动行为，可能将导致团队陷入被动。1.务必让与你任务有交集的人员完全了解对接内容。2. 修改别人的代码，必先与对方沟通，再动手修改。3.当修改框架代码，务必先做好设计/收集建议再作修改。4.日常多关心下同事的开发内容。5.组织日/周例会，纠正使用规范/收集问题等等。


2020-5-6
---
技术积累要回归起点。举两个曾经的疑问，1.常用内存字节长度有1、2、4和8，为什么跳过3、5、6和7？2. 为什有引用类型的语言不能/不建议操作地址？被外行问过，1.写完代不是就能运行了吗，为什么还要编译？

这些都是小问题大学问。激发/思考/回归这类问题，当然自己可以去翻书，但更高的回归效率应该是回答外行/新手“来自最原始的疑问”。还有就是行内多技术交流。

如果是想研究技术，就不要厌烦外行/新手的问题，不要担心因为回答不上问题而感到羞耻/或暴露了不能外见的私密似的/或爱面子怕被怼。

我一向认为技术交流，就像学术辩论一样，讨论的话题只有技术，末了的积极态度是赞赏和倾慕！


2020-2-18
---
Lua是用C实现的，可以说它先天就拥有操作系统级别的性能优势（当然最终要看Lua的实现效率），我甚至怀疑这种性能优势是Lua被广泛用于游戏开发的一个重要原因。Lua是我目前使用过最易用的编程语言，可能是考虑跨平台运行（ANSI C）的原因，它内置没有高级API，比如没有多线程、Socket api等。我特别喜欢Lua的安全模式(或称沙盒模式，pcall和xpcall)，有别于大多语言的异常捕捉，pcall(xpcall)通过返回错误码和定义错误处理函数的做法，令代码更加优雅。

Lua的简单易用，也必定让它走向另一个极端。变量赋值不需要类型一致（赋值只是让变量指向另一个lua对象），所以除非有清晰的定义规范和充分的注释，否则阅读代码时层层追溯一个lua对象的定义简直就是恶梦。跨平台的原因，Lua精简内置的功能，提供的接口很少，所以很多问题需要开发者自己解决，比如不要惊讶你的项目居然还要为lua封装一系列字符串操作接口。Lua用8字节来统一表示整数和浮点，你无法像其它编程语那样，为了精打细算内存去定义一个2字节整形或者4字节浮点数。一个“不适当”的赋值，Lua在你毫不知情下，暗暗地将table从线性转成哈希结构（或者哈希转线性结结构），这一方面无法确切地掌控内存，令程序容易踩入性能问题。



2019-12-10
---
C/C++不应该有垃圾回收。只要C/C++还是操作系统的主要实现语言，C/C++就不会有内置垃圾回收机制。这是近日看了[《垃圾回收的算法与实现》](https://book.douban.com/subject/26821357/)前几章后有感。书中没谈该到观点。只是明白了书中要表达到的意思后，回想起常有人抱怨C/C++没有垃圾回收，固有此想。

看了前面几章，主要介绍了几个GC算法：位图标记，复制gc，引用计数和分代gc。尽管这么多算法，但每种算法都解决同一个问题，对象什么时候被释放才是效率最大。因为频繁使用的对象就算没被引用，在空间和性能允许的条件下也应该被继续保留，而不是立即清除。保留多久的问题上就是各个GC实现细节差异。引用计数认为当计数小于等于0时就要释放对象，而分代认为最后创建的对象会被优先考虑GC。而算法在性能和空间的微小取舍上派生子版本。如标记GC算法，扩展出了复制标记和压缩标记算法。

各个垃圾回收算法各有特点，不存在一个通吃所有情况的GC算法。 C/C++的一大特性是“靠近”操作系统，为了更好性能，操作系统的核心部分是用C/C++和汇编语言写的，这里不是业务层，无法知首具体要处理的问题，如果是C/C++语言的设计者，使用哪个作为内置GC算法？答案是不解决这个问题。由业务层框架解决垃圾回收算法问题，根据使用场景特性选择适当的回收方案。

恐怕C/C++的完美之一是没有垃圾回收！


2019-12-8
---
个人认为单例模式是经常被玩坏了的设计模式。常看到业务框架中出现一大坨单例，究竟是需要单例还是用全局对象呢？频繁地敲打字符“GetInstance()”令我感到厌倦。回顾一下单例模式的需求特性：1. 类型不能实例化多次，否则内部会产生逻辑冲突。2.业务范围内不能获取到实例。然而我所遇到过大多数的单例都不满足条件1，可以很轻松实例化多次。而条件2是大家都喜欢使用它的原因，全局访问特性，能快速将功能“拼凑起来”。但它代价是放弃了进一步思考框架的解耦和内聚性。大多数情况下，我个人偏向用全局对象来替代单例，如果app是程序入口的全局对象，app.audio则是声音控制的管理对象。


2019-10-21
---
开源代码的功能要简洁。或者说刚好满足需求就好。功能越丰富，框架设计会考虑更多、更复杂、代码量更大。当增删改代码时，最终额外增加与需求不相关的人力成本。

<br>	
<br>	
<b>原文:<br>
<https://lizijie.github.io/2019/10/21/%E6%9D%82%E8%B0%88.html>
<br>
作者github:<br>	
<https://github.com/lizijie>	
</b>
